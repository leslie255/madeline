use std::{
    fmt::{Display, Write},
    rc::Rc,
};

use super::{
    stack_alloc::{StackAllocation, StackAllocator},
    vreg_alloc::{Register, VRegAllocation},
};
use crate::{
    fileformat::FileFormat,
    ir::{DataType, Instruction as IRInstruction, TopLevel as IRTopLevel},
};

#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
pub enum X86WordSize {
    Byte = 1,
    Word = 2,
    Dword = 4,
    Qword = 8,
}
impl From<DataType> for X86WordSize {
    fn from(dtype: DataType) -> Self {
        match dtype {
            DataType::U64
            | DataType::I64
            | DataType::USize
            | DataType::ISize
            | DataType::F64
            | DataType::Ptr => Self::Qword,
            DataType::U32 | DataType::I32 | DataType::F32 => Self::Dword,
            DataType::U16 | DataType::I16 => Self::Word,
            DataType::U8 | DataType::I8 => Self::Byte,
        }
    }
}

#[derive(Debug, Clone, PartialEq)]
pub enum Instruction {
    GlobalLabel(Rc<String>), // GlobalLabel are usually for functions, which are usually wrapped
    // in Rc because of their rapid occurance
    Label(String), // Labels aren't wrapped in Rc because they're mostly generated by the compiler
    FnProlog,
    Ret,
    AllocStack(usize),
    DeallocStack(usize),

    Mov(Operand, Operand),
    Movzx(Operand, Operand),
    Lea(Operand, Operand),

    Push(Operand),
    Pop(Operand),

    Call(Rc<String>),
}
impl Instruction {
    /// Shorthand for `pop rbp`
    pub fn pop_rop() -> Self {
        Instruction::Pop(X64Register::Rbp.into())
    }
}

#[derive(Debug, Clone, PartialEq)]
pub enum Operand {
    Reg(X64Register),
    Im([u8; 8]),
    Label(String),
    Load(EvalTreeNode),                 // [ ... ]
    WordPtr(X86WordSize, EvalTreeNode), // qword [ ... ]
}
impl Operand {
    pub fn gen_code(&self, file_format: FileFormat) -> Result<String, std::fmt::Error> {
        let mut code = String::new();
        match self {
            Self::Reg(reg) => write!(code, "{}", reg)?,
            Self::Im(bytes) => write!(code, "{}", u64::from_be_bytes(bytes.clone()))?,
            Self::Label(name) => write!(code, "{}", file_format.mangle(name))?,
            Self::Load(eval_tree) => write!(code, "[{}]", eval_tree)?,
            Self::WordPtr(size, eval_tree) => {
                write!(code, "{} [{}]", size.fmt_into_asm(), eval_tree)?
            }
        }
        Ok(code)
    }
    /// Shorthand for making a `word [rbp - {x}]` operand
    pub fn rbp_sub(word_size: X86WordSize, loc: usize) -> Self {
        Operand::WordPtr(
            word_size,
            EvalTreeNode::Sub(
                Box::new(EvalTreeNode::Reg(X64Register::Rbp)),
                Box::new(EvalTreeNode::Num(loc as u64)),
            ),
        )
    }
}
impl From<X64Register> for Operand {
    fn from(reg: X64Register) -> Self {
        Self::Reg(reg)
    }
}

#[derive(Debug, Clone, PartialEq)]
pub enum EvalTreeNode {
    // [ ... ] in asm
    Add(Box<Self>, Box<Self>),
    Sub(Box<Self>, Box<Self>),
    Mul(Box<Self>, Box<Self>),

    Num(u64),
    Reg(X64Register),
}
impl EvalTreeNode {
    pub fn priority(&self) -> usize {
        match self {
            Self::Add(_, _) => 0,
            Self::Sub(_, _) => 0,
            Self::Mul(_, _) => 1,
            Self::Num(_) => 2,
            Self::Reg(_) => 2,
        }
    }
    pub fn op_char(&self) -> char {
        match self {
            Self::Add(_, _) => '+',
            Self::Sub(_, _) => '-',
            Self::Mul(_, _) => '*',
            Self::Num(_) => '\0',
            Self::Reg(_) => '\0',
        }
    }
}
impl Display for EvalTreeNode {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::Add(lhs, rhs) | Self::Sub(lhs, rhs) | Self::Mul(lhs, rhs) => {
                if lhs.priority() < self.priority() {
                    write!(f, "({})", lhs)?;
                } else {
                    lhs.fmt(f)?;
                }
                self.op_char().fmt(f)?;
                if rhs.priority() < self.priority() {
                    write!(f, "({})", rhs)?;
                } else {
                    rhs.fmt(f)?;
                }
            }
            Self::Num(num) => {
                num.fmt(f)?;
            }
            Self::Reg(reg) => {
                reg.fmt(f)?;
            }
        }
        Ok(())
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum X64Register {
    Rax = 0x00,
    Rbx,
    Rcx,
    Rdx,
    Rsp,
    Rbp,
    Rsi,
    Rdi,
    R8,
    R9,
    R10,
    R11,
    R12,
    R13,
    R14,
    R15,

    Eax = 0x10,
    Ebx,
    Ecx,
    Edx,
    Esp,
    Ebp,
    Esi,
    Edi,
    R8d,
    R9d,
    R10d,
    R11d,
    R12d,
    R13d,
    R14d,
    R15d,

    Ax = 0x20,
    Bx,
    Cx,
    Dx,
    Sp,
    Bp,
    Si,
    Di,
    R8w,
    R9w,
    R10w,
    R11w,
    R12w,
    R13w,
    R14w,
    R15w,

    Al = 0x30,
    Bl,
    Cl,
    Dl,
    Spl,
    Bpl,
    Sil,
    Dil,
    R8b,
    R9b,
    R10b,
    R11b,
    R12b,
    R13b,
    R14b,
    R15b,
}

impl Display for X64Register {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            X64Register::Rax => write!(f, "rax")?,
            X64Register::Rbx => write!(f, "rbx")?,
            X64Register::Rcx => write!(f, "rcx")?,
            X64Register::Rdx => write!(f, "rdx")?,
            X64Register::Rsp => write!(f, "rsp")?,
            X64Register::Rbp => write!(f, "rbp")?,
            X64Register::Rsi => write!(f, "rsi")?,
            X64Register::Rdi => write!(f, "rdi")?,
            X64Register::R8 => write!(f, "r8")?,
            X64Register::R9 => write!(f, "r9")?,
            X64Register::R10 => write!(f, "r10")?,
            X64Register::R11 => write!(f, "r11")?,
            X64Register::R12 => write!(f, "r12")?,
            X64Register::R13 => write!(f, "r13")?,
            X64Register::R14 => write!(f, "r14")?,
            X64Register::R15 => write!(f, "r15")?,
            X64Register::Eax => write!(f, "eax")?,
            X64Register::Ebx => write!(f, "ebx")?,
            X64Register::Ecx => write!(f, "ecx")?,
            X64Register::Edx => write!(f, "edx")?,
            X64Register::Esp => write!(f, "esp")?,
            X64Register::Ebp => write!(f, "ebp")?,
            X64Register::Esi => write!(f, "esi")?,
            X64Register::Edi => write!(f, "edi")?,
            X64Register::R8d => write!(f, "r8d")?,
            X64Register::R9d => write!(f, "r9d")?,
            X64Register::R10d => write!(f, "r10d")?,
            X64Register::R11d => write!(f, "r11d")?,
            X64Register::R12d => write!(f, "r12d")?,
            X64Register::R13d => write!(f, "r13d")?,
            X64Register::R14d => write!(f, "r14d")?,
            X64Register::R15d => write!(f, "r15d")?,
            X64Register::Ax => write!(f, "ax")?,
            X64Register::Bx => write!(f, "bx")?,
            X64Register::Cx => write!(f, "cx")?,
            X64Register::Dx => write!(f, "dx")?,
            X64Register::Sp => write!(f, "sp")?,
            X64Register::Bp => write!(f, "bp")?,
            X64Register::Si => write!(f, "si")?,
            X64Register::Di => write!(f, "di")?,
            X64Register::R8w => write!(f, "r8w")?,
            X64Register::R9w => write!(f, "r9w")?,
            X64Register::R10w => write!(f, "r10w")?,
            X64Register::R11w => write!(f, "r11w")?,
            X64Register::R12w => write!(f, "r12w")?,
            X64Register::R13w => write!(f, "r13w")?,
            X64Register::R14w => write!(f, "r14w")?,
            X64Register::R15w => write!(f, "r15w")?,
            X64Register::Al => write!(f, "al")?,
            X64Register::Bl => write!(f, "bl")?,
            X64Register::Cl => write!(f, "cl")?,
            X64Register::Dl => write!(f, "dl")?,
            X64Register::Spl => write!(f, "spl")?,
            X64Register::Bpl => write!(f, "bpl")?,
            X64Register::Sil => write!(f, "sil")?,
            X64Register::Dil => write!(f, "dil")?,
            X64Register::R8b => write!(f, "r8b")?,
            X64Register::R9b => write!(f, "r9b")?,
            X64Register::R10b => write!(f, "r10b")?,
            X64Register::R11b => write!(f, "r11b")?,
            X64Register::R12b => write!(f, "r12b")?,
            X64Register::R13b => write!(f, "r13b")?,
            X64Register::R14b => write!(f, "r14b")?,
            X64Register::R15b => write!(f, "r15b")?,
        }
        Ok(())
    }
}

impl X64Register {
    pub fn from_raw(raw: usize) -> Self {
        unsafe {
            let ptr = &raw as *const usize;
            return *(ptr as *const Self);
        }
    }
}
impl X64Register {
    fn of_size(self, size: X86WordSize) -> Self {
        let mut raw = self as usize;
        raw &= 0x0F;
        match size {
            X86WordSize::Byte => raw += 0x30,
            X86WordSize::Word => raw += 0x20,
            X86WordSize::Dword => raw += 0x10,
            X86WordSize::Qword => (),
        }
        Self::from_raw(raw)
    }
    #[allow(dead_code)]
    fn word_size(self) -> X86WordSize {
        match (self as usize) & 0xF0 {
            0x00 => X86WordSize::Qword,
            0x10 => X86WordSize::Dword,
            0x20 => X86WordSize::Word,
            0x30 => X86WordSize::Byte,
            _ => panic!(),
        }
    }
}
impl Register for X64Register {
    fn caller_saved() -> Vec<Self> {
        vec![
            Self::Rdi,
            Self::Rsi,
            Self::Rdx,
            Self::Rcx,
            Self::R8,
            Self::R9,
        ]
    }
    fn callee_saved() -> Vec<Self> {
        vec![
            Self::Rbx,
            Self::Rsp,
            Self::Rbp,
            Self::R10,
            Self::R11,
            Self::R12,
            Self::R13,
            Self::R14,
            Self::R15,
        ]
    }
}
impl X86WordSize {
    fn fmt_into_asm(&self) -> String {
        let mut str = String::with_capacity(5);
        match self {
            X86WordSize::Byte => write!(str, "byte"),
            X86WordSize::Word => write!(str, "word"),
            X86WordSize::Dword => write!(str, "dword"),
            X86WordSize::Qword => write!(str, "qword"),
        }
        .unwrap();
        str
    }
}

pub fn gen_asm_from_model(
    file_format: FileFormat,
    instructions: Vec<Instruction>,
    target: &mut dyn Write,
) -> Result<(), std::fmt::Error> {
    for instruction in instructions {
        match instruction {
            Instruction::GlobalLabel(name) => writeln!(
                target,
                "\tglobal\t{}\n{}:",
                file_format.mangle(&name),
                file_format.mangle(&name)
            )?,
            Instruction::Label(name) => writeln!(target, "{}:", file_format.mangle(&name))?,
            Instruction::FnProlog => writeln!(target, "\tpush\trbp\n\tmov\trbp, rsp")?,
            Instruction::Ret => writeln!(target, "\tret")?,
            Instruction::AllocStack(depth) => writeln!(target, "\tsub\trsp, {}", depth)?,
            Instruction::DeallocStack(depth) => writeln!(target, "\tadd\trsp, {}", depth)?,
            Instruction::Mov(oper0, oper1) => match (oper0, oper1) {
                (Operand::Reg(reg), Operand::Im([0, 0, 0, 0, 0, 0, 0, 0])) => {
                    writeln!(target, "\txor\t{}, {}", reg, reg)?
                }
                (oper0, oper1) => writeln!(
                    target,
                    "\tmov\t{}, {}",
                    oper0.gen_code(file_format)?,
                    oper1.gen_code(file_format)?,
                )?,
            },
            Instruction::Movzx(oper0, oper1) => writeln!(
                target,
                "\tmovzx\t{}, {}",
                oper0.gen_code(file_format)?,
                oper1.gen_code(file_format)?
            )?,
            Instruction::Lea(oper0, oper1) => writeln!(
                target,
                "\tlea\t{}, {}",
                oper0.gen_code(file_format)?,
                oper1.gen_code(file_format)?
            )?,
            Instruction::Push(oper0) => {
                writeln!(target, "\tpush\t{}", oper0.gen_code(file_format)?)?
            }
            Instruction::Pop(oper0) => writeln!(target, "\tpop\t{}", oper0.gen_code(file_format)?)?,
            Instruction::Call(name) => writeln!(target, "\tcall\t{}", file_format.mangle(&name))?,
        }
    }
    Ok(())
}

pub fn gen_code(ir: Vec<IRTopLevel>) -> Vec<Instruction> {
    let mut generated = Vec::<Instruction>::new();
    for ir_top_level in ir {
        match ir_top_level {
            IRTopLevel::Extern(_) => todo!(),
            IRTopLevel::Fn { name, args, body } => gen_inside_fn(name, args, body, &mut generated),
        }
    }
    generated
}

fn gen_inside_fn(
    name: Rc<String>,
    args: Vec<DataType>,
    body: Vec<IRInstruction>,
    target: &mut Vec<Instruction>,
) {
    let _ = &args; // Silence the warning
    let mut stack_allocator = StackAllocator::new(16, 8);
    let vreg_allocations =
        VRegAllocation::<X64Register>::generate_from(&body, &mut stack_allocator);

    vreg_allocations.print_reg_lifetime_map();
    vreg_allocations.print_reg_infos();

    let stack_alloc = stack_allocator.allocate();
    println!("Stack allocation:");
    stack_alloc.locations.iter().enumerate().for_each(|(i, l)| {
        println!("{i}:\t{l}");
    });
    println!("Stack depth: {}", stack_alloc.stack_depth);

    target.push(Instruction::GlobalLabel(name));
    target.push(Instruction::FnProlog);
    if !stack_alloc.locations.is_empty() {
        target.push(Instruction::AllocStack(stack_alloc.stack_depth));
    }
    for (step, instruction) in body.into_iter().enumerate() {
        match instruction {
            IRInstruction::DefReg { id, rhs } => {
                let (rhs_dtype, rhs_operand) = gen_operand(*rhs, &stack_alloc, &vreg_allocations);
                let lhs_operand = if let Some(real_reg) = vreg_allocations.get_alloced_reg(id) {
                    real_reg.of_size(rhs_dtype.into()).into()
                } else if let Some(stackspace_id) = vreg_allocations.get_alloced_stackptr(id) {
                    Operand::rbp_sub(rhs_dtype.into(), stack_alloc.var_location(stackspace_id))
                } else {
                    todo!("Allocate VReg on stack")
                };
                target.push(Instruction::Mov(lhs_operand, rhs_operand))
            }
            IRInstruction::Store { id: vreg_id, rhs } => {
                let stackspace_id = vreg_allocations
                    .get_alloced_stackptr(vreg_id)
                    .expect("Storing into a register who is not a stack pointer");
                let stack_location = stack_alloc.var_location(stackspace_id);
                let (dtype, rhs_operand) = gen_operand(*rhs, &stack_alloc, &vreg_allocations);
                target.push(Instruction::Mov(
                    Operand::rbp_sub(dtype.into(), stack_location),
                    rhs_operand,
                ));
            }
            IRInstruction::Ret(ret_val) => {
                if let Some(ret_val) = ret_val {
                    // Has return value
                    let (operand_type, operand) =
                        gen_operand(*ret_val, &stack_alloc, &vreg_allocations);
                    let operand_type = operand_type;
                    target.push(Instruction::Mov(
                        X64Register::Rax.of_size(operand_type.into()).into(),
                        operand,
                    ));
                }
                if !stack_alloc.locations.is_empty() {
                    target.push(Instruction::DeallocStack(stack_alloc.stack_depth));
                }
                target.push(Instruction::pop_rop());
                target.push(Instruction::Ret);
            }
            IRInstruction::Call {
                ret_type: _,
                fn_name,
                args,
            } => {
                let arg_regs = X64Register::caller_saved();
                // TODO: push currently occupied registers
                // Load arguments in reverse order because for some reason gcc and clang do that
                vreg_allocations
                    .for_each_living_reg(step, |r| target.push(Instruction::Push(r.into())));
                for (i, arg_instruction) in args.into_iter().rev().enumerate() {
                    let (arg_dtype, arg_operand) =
                        gen_operand(arg_instruction, &stack_alloc, &vreg_allocations);
                    let arg_reg = arg_regs[i].of_size(arg_dtype.into());
                    target.push(Instruction::Mov(arg_reg.into(), arg_operand))
                }
                target.push(Instruction::Call(fn_name));
                vreg_allocations
                    .for_each_living_reg_rev(step, |r| target.push(Instruction::Pop(r.into())));
            }
            IRInstruction::Label(name) => target.push(Instruction::Label(name)),
            illegal => panic!("{:?} is illegal as root node", illegal),
        }
    }
}

/// Generate an operand
/// Will panic if the instruction is not an operand (including calls)
fn gen_operand(
    instruction: IRInstruction,
    stack_alloc: &StackAllocation,
    vreg_alloc: &VRegAllocation<X64Register>,
) -> (DataType, Operand) {
    match instruction {
        IRInstruction::Arg(_, _) => todo!(),
        IRInstruction::Reg(dtype, reg) => (
            dtype,
            vreg_alloc
                .get_alloced_reg(reg)
                .expect("No real register allocated for VReg")
                .of_size(dtype.into())
                .into(),
        ),
        IRInstruction::UInt(dtype, val) => (dtype, Operand::Im(val.to_be_bytes())),
        IRInstruction::Int(dtype, val) => (dtype, Operand::Im(val.to_be_bytes())),
        IRInstruction::Float(dtype, val) => (dtype, Operand::Im(val.to_be_bytes())),
        IRInstruction::Load { id, dtype } => (
            dtype,
            Operand::rbp_sub(
                dtype.into(),
                stack_alloc.var_location(
                    vreg_alloc
                        .get_alloced_stackptr(id)
                        .expect("Loading from a regsiter that is not a stack ptr"),
                ),
            ),
        ),
        illegal => panic!("{:?} cannot be an operand", illegal),
    }
}
