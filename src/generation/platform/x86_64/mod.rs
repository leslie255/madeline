mod reg;

use std::{
    fmt::{Display, Write},
    rc::Rc,
};

use reg::X64Register;

use crate::{
    fileformat::FileFormat,
    generation::{
        stack_alloc::{StackAllocation, StackAllocator},
        vreg_alloc::{Register, VRegAllocation},
    },
    ir::{DataType, Instruction as IRInstruction, TopLevel as IRTopLevel},
};

#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
pub enum X86WordSize {
    Byte = 1,
    Word = 2,
    Dword = 4,
    Qword = 8,
}
impl From<DataType> for X86WordSize {
    fn from(dtype: DataType) -> Self {
        match dtype {
            DataType::U64
            | DataType::I64
            | DataType::USize
            | DataType::ISize
            | DataType::F64
            | DataType::Ptr => Self::Qword,
            DataType::U32 | DataType::I32 | DataType::F32 => Self::Dword,
            DataType::U16 | DataType::I16 => Self::Word,
            DataType::U8 | DataType::I8 => Self::Byte,
        }
    }
}

#[derive(Debug, Clone, PartialEq)]
pub enum Instruction {
    GlobalLabel(Rc<String>), // GlobalLabel are usually for functions, which are usually wrapped
    // in Rc because of their rapid occurance
    Label(String), // Labels aren't wrapped in Rc because they're mostly generated by the compiler
    FnProlog,
    Ret,
    AllocStack(usize),
    DeallocStack(usize),

    Mov(Operand, Operand),
    Movzx(Operand, Operand),
    Lea(Operand, Operand),

    Push(Operand),
    Pop(Operand),

    Call(Rc<String>),
}
impl Instruction {
    /// Shorthand for `pop rbp`
    pub fn pop_rop() -> Self {
        Instruction::Pop(X64Register::Rbp.into())
    }
}

#[derive(Debug, Clone, PartialEq)]
pub enum Operand {
    Reg(X64Register),
    Im([u8; 8]),
    Label(String),
    Load(EvalTreeNode),                 // [ ... ]
    WordPtr(X86WordSize, EvalTreeNode), // qword [ ... ]
}
impl Operand {
    pub fn gen_code(&self, file_format: FileFormat) -> Result<String, std::fmt::Error> {
        let mut code = String::new();
        match self {
            Self::Reg(reg) => write!(code, "{}", reg)?,
            Self::Im(bytes) => write!(code, "{}", u64::from_be_bytes(bytes.clone()))?,
            Self::Label(name) => write!(code, "{}", file_format.mangle(name))?,
            Self::Load(eval_tree) => write!(code, "[{}]", eval_tree)?,
            Self::WordPtr(size, eval_tree) => {
                write!(code, "{} [{}]", size.fmt_into_asm(), eval_tree)?
            }
        }
        Ok(code)
    }
    /// Shorthand for making a `word [rbp - {x}]` operand
    pub fn rbp_sub(word_size: X86WordSize, loc: usize) -> Self {
        Operand::WordPtr(
            word_size,
            EvalTreeNode::Sub(
                Box::new(EvalTreeNode::Reg(X64Register::Rbp)),
                Box::new(EvalTreeNode::Num(loc as u64)),
            ),
        )
    }
}
impl From<X64Register> for Operand {
    fn from(reg: X64Register) -> Self {
        Self::Reg(reg)
    }
}

#[derive(Debug, Clone, PartialEq)]
pub enum EvalTreeNode {
    // [ ... ] in asm
    Add(Box<Self>, Box<Self>),
    Sub(Box<Self>, Box<Self>),
    Mul(Box<Self>, Box<Self>),

    Num(u64),
    Reg(X64Register),
}
impl EvalTreeNode {
    pub fn priority(&self) -> usize {
        match self {
            Self::Add(_, _) => 0,
            Self::Sub(_, _) => 0,
            Self::Mul(_, _) => 1,
            Self::Num(_) => 2,
            Self::Reg(_) => 2,
        }
    }
    pub fn op_char(&self) -> char {
        match self {
            Self::Add(_, _) => '+',
            Self::Sub(_, _) => '-',
            Self::Mul(_, _) => '*',
            Self::Num(_) => '\0',
            Self::Reg(_) => '\0',
        }
    }
}
impl Display for EvalTreeNode {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::Add(lhs, rhs) | Self::Sub(lhs, rhs) | Self::Mul(lhs, rhs) => {
                if lhs.priority() < self.priority() {
                    write!(f, "({})", lhs)?;
                } else {
                    lhs.fmt(f)?;
                }
                self.op_char().fmt(f)?;
                if rhs.priority() < self.priority() {
                    write!(f, "({})", rhs)?;
                } else {
                    rhs.fmt(f)?;
                }
            }
            Self::Num(num) => {
                num.fmt(f)?;
            }
            Self::Reg(reg) => {
                reg.fmt(f)?;
            }
        }
        Ok(())
    }
}
impl From<X64Register> for EvalTreeNode {
    fn from(reg: X64Register) -> Self {
        Self::Reg(reg)
    }
}
impl X64Register {
    pub fn from_raw(raw: usize) -> Self {
        unsafe {
            let ptr = &raw as *const usize;
            return *(ptr as *const Self);
        }
    }
}
impl X64Register {
    fn of_size(self, size: X86WordSize) -> Self {
        let mut raw = self as usize;
        raw &= 0x0F;
        match size {
            X86WordSize::Byte => raw += 0x30,
            X86WordSize::Word => raw += 0x20,
            X86WordSize::Dword => raw += 0x10,
            X86WordSize::Qword => (),
        }
        Self::from_raw(raw)
    }
    #[allow(dead_code)]
    fn word_size(self) -> X86WordSize {
        match (self as usize) & 0xF0 {
            0x00 => X86WordSize::Qword,
            0x10 => X86WordSize::Dword,
            0x20 => X86WordSize::Word,
            0x30 => X86WordSize::Byte,
            _ => panic!(),
        }
    }
}
impl Register for X64Register {
    fn caller_saved() -> Vec<Self> {
        vec![
            Self::Rdi,
            Self::Rsi,
            Self::Rdx,
            Self::Rcx,
            Self::R8,
            Self::R9,
        ]
    }
    fn callee_saved() -> Vec<Self> {
        vec![
            Self::Rbx,
            Self::Rsp,
            Self::Rbp,
            Self::R10,
            Self::R11,
            Self::R12,
            Self::R13,
            Self::R14,
            Self::R15,
        ]
    }
}
impl X86WordSize {
    fn fmt_into_asm(&self) -> String {
        let mut str = String::with_capacity(5);
        match self {
            X86WordSize::Byte => write!(str, "byte"),
            X86WordSize::Word => write!(str, "word"),
            X86WordSize::Dword => write!(str, "dword"),
            X86WordSize::Qword => write!(str, "qword"),
        }
        .unwrap();
        str
    }
}

pub fn gen_asm_from_model(
    file_format: FileFormat,
    instructions: Vec<Instruction>,
    target: &mut dyn Write,
) -> Result<(), std::fmt::Error> {
    for instruction in instructions {
        match instruction {
            Instruction::GlobalLabel(name) => writeln!(
                target,
                "\tglobal\t{}\n{}:",
                file_format.mangle(&name),
                file_format.mangle(&name)
            )?,
            Instruction::Label(name) => writeln!(target, "{}:", file_format.mangle(&name))?,
            Instruction::FnProlog => writeln!(target, "\tpush\trbp\n\tmov\trbp, rsp")?,
            Instruction::Ret => writeln!(target, "\tret")?,
            Instruction::AllocStack(depth) => writeln!(target, "\tsub\trsp, {}", depth)?,
            Instruction::DeallocStack(depth) => writeln!(target, "\tadd\trsp, {}", depth)?,
            Instruction::Mov(oper0, oper1) => match (oper0, oper1) {
                (Operand::Reg(reg), Operand::Im([0, 0, 0, 0, 0, 0, 0, 0])) => {
                    writeln!(target, "\txor\t{}, {}", reg, reg)?
                }
                (oper0, oper1) => writeln!(
                    target,
                    "\tmov\t{}, {}",
                    oper0.gen_code(file_format)?,
                    oper1.gen_code(file_format)?,
                )?,
            },
            Instruction::Movzx(oper0, oper1) => writeln!(
                target,
                "\tmovzx\t{}, {}",
                oper0.gen_code(file_format)?,
                oper1.gen_code(file_format)?
            )?,
            Instruction::Lea(oper0, oper1) => writeln!(
                target,
                "\tlea\t{}, {}",
                oper0.gen_code(file_format)?,
                oper1.gen_code(file_format)?
            )?,
            Instruction::Push(oper0) => {
                writeln!(target, "\tpush\t{}", oper0.gen_code(file_format)?)?
            }
            Instruction::Pop(oper0) => writeln!(target, "\tpop\t{}", oper0.gen_code(file_format)?)?,
            Instruction::Call(name) => writeln!(target, "\tcall\t{}", file_format.mangle(&name))?,
        }
    }
    Ok(())
}

pub fn gen_code(ir: Vec<IRTopLevel>) -> Vec<Instruction> {
    let mut generated = Vec::<Instruction>::new();
    for ir_top_level in ir {
        match ir_top_level {
            IRTopLevel::Extern(_) => todo!(),
            IRTopLevel::Fn { name, args, body } => gen_inside_fn(name, args, body, &mut generated),
        }
    }
    generated
}

fn gen_inside_fn(
    name: Rc<String>,
    args: Vec<DataType>,
    body: Vec<IRInstruction>,
    target: &mut Vec<Instruction>,
) {
    let _ = &args; // Silence the warning
    let mut stack_allocator = StackAllocator::new(16, 8);
    let vreg_allocations =
        VRegAllocation::<X64Register>::generate_from(&body, &mut stack_allocator);

    vreg_allocations.print_reg_lifetime_map();
    vreg_allocations.print_reg_infos();

    let stack_alloc = stack_allocator.allocate();
    println!("Stack allocation:");
    stack_alloc.locations.iter().enumerate().for_each(|(i, l)| {
        println!("{i}:\t{l}");
    });
    println!("Stack depth: {}", stack_alloc.stack_depth);

    target.push(Instruction::GlobalLabel(name));
    target.push(Instruction::FnProlog);
    if !stack_alloc.locations.is_empty() {
        target.push(Instruction::AllocStack(stack_alloc.stack_depth));
    }
    for (step, instruction) in body.into_iter().enumerate() {
        match instruction {
            IRInstruction::DefReg { id, rhs } => {
                if let IRInstruction::Alloc(_) = *rhs {
                    continue;
                }
                let (rhs_dtype, rhs_oper) = gen_operand(*rhs, &stack_alloc, &vreg_allocations);
                let size: X86WordSize = rhs_dtype.into();
                if let Some(real_reg) = vreg_allocations.get_alloced_reg(id) {
                    let lhs_oper = real_reg.of_size(size).into();
                    gen_move_instruction(size, lhs_oper, size, rhs_oper, target);
                } else if let Some(stackspace_id) = vreg_allocations.get_alloced_stackptr(id) {
                    let lhs_oper =
                        Operand::rbp_sub(rhs_dtype.into(), stack_alloc.var_location(stackspace_id));
                    gen_move_instruction(size, lhs_oper, size, rhs_oper, target);
                } else if let Some(_) = vreg_allocations.get_alloced_const(id) {
                    // No need to generate anything here since for every occurance of this register
                    // we can just replace it with the const value
                }
                // TODO: Allocate VReg on stack
                // Sometimes a VReg doesn't not have any allocation, it's because VReg allocator
                // decides to cull it
            }
            IRInstruction::Store { id: vreg_id, rhs } => {
                let stackspace_id = vreg_allocations
                    .get_alloced_stackptr(vreg_id)
                    .expect("Storing into a register who is not a stack pointer");
                let stack_location = stack_alloc.var_location(stackspace_id);
                let (rhs_dtype, rhs_oper) = gen_operand(*rhs, &stack_alloc, &vreg_allocations);
                let size: X86WordSize = rhs_dtype.into();
                let lhs_oper = Operand::rbp_sub(rhs_dtype.into(), stack_location);
                gen_move_instruction(size, lhs_oper, size, rhs_oper, target);
            }
            IRInstruction::Ret(ret_val) => {
                if let Some(ret_val) = ret_val {
                    // Has return value
                    let (oper_dtype, operand) =
                        gen_operand(*ret_val, &stack_alloc, &vreg_allocations);
                    let size: X86WordSize = oper_dtype.into();
                    let rax_sized = X64Register::Rax.of_size(size);
                    gen_move_instruction(size, rax_sized.into(), size, operand, target);
                }
                if !stack_alloc.locations.is_empty() {
                    target.push(Instruction::DeallocStack(stack_alloc.stack_depth));
                }
                target.push(Instruction::pop_rop());
                target.push(Instruction::Ret);
            }
            IRInstruction::Call {
                ret_type: _,
                fn_name,
                args,
            } => {
                let arg_regs = X64Register::caller_saved();
                // TODO: push currently occupied registers
                // Load arguments in reverse order because for some reason gcc and clang do that
                vreg_allocations
                    .for_each_living_reg(step, |r| target.push(Instruction::Push(r.into())));
                for (i, arg_instruction) in args.into_iter().rev().enumerate() {
                    let (arg_dtype, arg_oper) =
                        gen_operand(arg_instruction, &stack_alloc, &vreg_allocations);
                    let size: X86WordSize = arg_dtype.into();
                    let arg_reg = arg_regs[i].of_size(size);
                    gen_move_instruction(size, arg_reg.into(), size, arg_oper, target);
                }
                target.push(Instruction::Call(fn_name));
                vreg_allocations
                    .for_each_living_reg_rev(step, |r| target.push(Instruction::Pop(r.into())));
            }
            IRInstruction::Label(name) => target.push(Instruction::Label(name)),
            illegal => panic!("{:?} is illegal as root node", illegal),
        }
    }
}

/// Generate an operand
/// Will panic if the instruction is not an operand (including calls)
fn gen_operand(
    instruction: IRInstruction,
    stack_alloc: &StackAllocation,
    vreg_alloc: &VRegAllocation<X64Register>,
) -> (DataType, Operand) {
    match instruction {
        IRInstruction::Arg(_, _) => todo!(),
        IRInstruction::Reg(dtype, reg_id) => (
            dtype,
            if let Some(reg) = vreg_alloc.get_alloced_reg(reg_id) {
                reg.of_size(dtype.into()).into()
            } else if let Some(val) = vreg_alloc.get_alloced_const(reg_id) {
                Operand::Im(val)
            } else if let Some(stackspace_id) = vreg_alloc.get_alloced_stackptr(reg_id) {
                let stack_loc = stack_alloc.var_location(stackspace_id);
                Operand::Load(EvalTreeNode::Sub(
                    Box::new(X64Register::Rbp.into()),
                    Box::new(EvalTreeNode::Num(stack_loc as u64)),
                ))
            } else {
                panic!(
                    "VReg allocation type not supported by x86_64 codegen (vreg: {})",
                    reg_id
                )
            },
        ),
        IRInstruction::UInt(dtype, val) => (dtype, Operand::Im(val.to_be_bytes())),
        IRInstruction::Int(dtype, val) => (dtype, Operand::Im(val.to_be_bytes())),
        IRInstruction::Float(dtype, val) => (dtype, Operand::Im(val.to_be_bytes())),
        IRInstruction::Load { id, dtype } => (
            dtype,
            Operand::rbp_sub(
                dtype.into(),
                stack_alloc.var_location(
                    vreg_alloc
                        .get_alloced_stackptr(id)
                        .expect("Loading from a regsiter that is not a stack ptr"),
                ),
            ),
        ),
        illegal => panic!("{:?} cannot be an operand", illegal),
    }
}

/// Generate a `mov` instruction
fn gen_move_instruction(
    lhs_size: X86WordSize,
    lhs_oper: Operand,
    rhs_size: X86WordSize,
    rhs_oper: Operand,
    target: &mut Vec<Instruction>,
) {
    match (&lhs_oper, &rhs_oper) {
        (Operand::WordPtr(_, _), Operand::Load(_)) => {
            let rax = X64Register::Rax.of_size(lhs_size);
            target.push(Instruction::Lea(rax.into(), lhs_oper));
            target.push(Instruction::Mov(rhs_oper, rax.into()));
        }
        (_, Operand::Load(_)) => target.push(Instruction::Lea(lhs_oper, rhs_oper)),
        (Operand::WordPtr(_, _), Operand::WordPtr(_, _)) => {
            let rax = X64Register::Rax.of_size(lhs_size);
            target.push(Instruction::Mov(rax.into(), lhs_oper));
            target.push(Instruction::Mov(rhs_oper, rax.into()));
        }
        _ => {
            if rhs_size < lhs_size {
                target.push(Instruction::Movzx(lhs_oper, rhs_oper));
            } else {
                target.push(Instruction::Mov(lhs_oper, rhs_oper));
            }
        }
    }
}
